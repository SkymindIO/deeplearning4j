# UDFs

## Status
**Discussion**

Proposed by: Adam Gibson (31 Jan 2023)


## Context

Users should be able to define their own custom operations including custom gradients.
Right now in order to define a UDF it would not be properly integrated
unless you handle the following:
1. Registering the op with the ImportClassMappings op registry
2. Special code paths in the op executioners that support calling user defined code
3. Special code paths for serialization to handle properly loading a samediff graph with
the correct op
4. A direct function call in samediff itself tha that handles properly registering the op as part of the graph


## Proposal


Support custom UDFS

1. An op type so the FlatBuffersMapper (used for saving graphs) knows how to save/load UDFs
2. A base class extending DynamicCustom for having clear method/constructor overrides for defining a custom op
3. An exec method where the user passes in relevant inputs and will be what gets used by the op executioner (rather than going down to c++)
4. A hook in samediff with something like: sd.udf(..)
5. An annotation or subclass scanner like we discussed for registration in relevant areas like the the ImportClassMappings


All of these components above work together to accomplish the following:
1. Annotation scanning for discovering user defined ops and registering them with the op registry
2. Users extend our base class to create their custom UDFS
3. Samediff integrates UDFS as follows:
```java
SameDiff sd = SameDiff.create();
UserDefinedCustomOp userDefinedCustomOp = ...;
SDVariable[] opOutputs = sd.doUdf(userDefinedCustomOp);
```

The above registers the op with the above graph. When an op is registered,
it is saved/loaded with the graph like any normal op would be.

4. We use annotation scanning to dynamically create ops via reflection when a graph is loaded.


Below is an example:
```java
@UserDefinedOp //annotation for discovering custom ops to register
public class TestAddUdf extends UserDefinedCustomOp { //class to extend
    //various constructors needed to create the op
    public TestAddUdf() {
        super();
       // an empty constructor. This is used when creating a graph from flatbuffers in the underlying { org.nd4j.autodiff.samediff.serde.FlatBuffersMapper}.
    }

    
    
    //note the other constructors here can be whatever a user wishes
    //custom ops usually will take in a samediff instance + 1 or more SDVariable
    //args, these are the bare minimum components to instantiate an op
    //in each of these a super(..) is called where it properly configures
    //the op to be used within the samediff graph that's passed in
    
    public TestAddUdf(SameDiff sameDiff, SDVariable arg) {
        super(sameDiff, arg);
    }

    public TestAddUdf(SameDiff sameDiff, SDVariable[] args) {
        super(sameDiff, args);
    }

    //used to calculate the output variables when registering an op with a graph
    @Override
    public List<DataType> calculateOutputDataTypes(List<DataType> dataTypes) {
        //A user must implement calculateOutputDataTypes(List) this is used in
        //samediff to determine how many output variables are needed when it can't determine that
        //from getNumOutputs()
        return Arrays.asList(dataTypes.get(0));
    }

    @Override
    public void setPropertiesForFunction(Map<String, Object> properties) {
        //A user can define properties as fields. if a user does so,
        //please ensure that you implement setPropertiesForFunction(Map)
        //propertiesForFunction() these are used to create an op from scratch
        // when saving/loading a model.
    }

 

    @Override
    public Map<String, Object> propertiesForFunction() {
        //returns properties (fields on the java class) as a map
        //properties can be seen as any value that is a field on the op itself
        //note that these properties are optional and may not be needed depending on the op
        //all properties will end up being passed to the underlying iArguments,tArguments and other
        //associated data structures inherited from DynamicCustomOp
        return Collections.emptyMap();
    }

    @Override
    public int getNumOutputs() {
        //the number of outputs for the op
        //note this is an integer, for scenarios where variable numbers of outputs
        //are involved a user will need to use an SDVariable.eval() call + an int
        //in order to get the number of outputs
        return 1;
    }

    @Override
    public String opName() {
        //the op name, needs to be defined in order to register properly with the registry
        return "test_add_udf";
    }

    @Override
    public void configureFromArguments() {
       //a hook for configuring the op after it's created
        //   for configuration from specified arguments such as ints, floats/doubles, and input variables.
        // The arguments referenced are the underlying arguments that get passed to every c/c++ ops. This includes
        // theiArguments,tArguments,dArguments,inputArguments,outputArguments
    }

    @Override
    public void configureWithSameDiff(SameDiff sameDiff) {
        this.sameDiff = sameDiff;
        //a hook for configuring the op after it's instantiated
        //but needs to pull information from the samediff graph
        // configureWithSameDiff(SameDiff) implemented: this is for handling initialization after
        // the op is created. This will initiate values using the relevant samediff metadata. This includes obtaining things like
        //input and output argument metadata from SDVariable found as args()
    }

    @Override
    public boolean isInplaceCall() {
        //whether the inputs are also the outputs
        //note if an op is in place extra care should be taken to avoid bugs
        //this is especially true when an input to an op is a view 
        return false;
    }

    
    @Override
    public List<LongShapeDescriptor> calculateOutputShape() {
        //describes how to calculate an output shape based on the inputs
        //note calculate output shape is called in response to dynamically creating
        //output arrays that are then used to store the result of an op's execution
       //note this is not called when an op is in place
        return Arrays.asList(inputArguments.get(0).shapeDescriptor());
    }

    @Override
    public List<LongShapeDescriptor> calculateOutputShape(OpContext oc) {
        //describes how to calculate an output shape based on the inputs from the op context
        //note calculate output shape is called in response to dynamically creating
        //output arrays that are then used to store the result of an op's execution
        //different above, we obtain the inputs from the op context rather than the op itself
        //note this is not called when an op is in place
        return Arrays.asList(oc.getInputArrays().get(0).shapeDescriptor());
    }

    @Override
    public List<SDVariable> doDiff(List<SDVariable> f1) {
        //a custom gradient definition
        //A user must implement doDiff(List) this is where a user's custom gradient definition goes.
        //This is required if the op is to  be used for training. The doDiff should return 1 gradient for each input.
        return new AddBpOp(sameDiff, larg(), rarg(), f1.get(0)).outputs();
    }

    @Override
    public void exec() {
        //the exec method for op itself, comprised of op execution and setting outputs
        //for the op
        AddOp addOp = new AddOp();
        addOp.addInputArgument(inputArguments.get(0),inputArguments.get(1));
        Nd4j.getExecutioner().exec(addOp);
        this.outputArguments.addAll(addOp.outputArguments);
    }

    @Override
    public void exec(OpContext opContext) {
        //the exec method for op itself, comprised of op execution and setting outputs
        //for the op context
        Nd4j.getExecutioner().exec(new AddOp(),opContext);
    }
}


```

With the above definition, a user just has to pass in a created op as an instantiated object.
As long as an op is annotated it is properly integrated with the samediff graph.

When executing, the special code paths in the op executioners will call exec() or exec(opContext)

At the end when we are finished implementing an op we will have done the following:


## Consequences

### Advantages

* Allows users to define their own ops to make optimizations or to introduce custom ops
for use within samediff
* Augments model import by combining annotation scanning from model import with 
annotation registration of udfs with similar annotations

### Disadvantages
* A bit lower level which means users can misuse the api or encounter bugs they might not 
otherwise with ops maintained in the core framework