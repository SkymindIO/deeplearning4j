# UDFs

## Status
**Discussion**

Proposed by: Adam Gibson (31 Jan 2023)


## Context

Users should be able to define their own custom operations including custom gradients.
Right now in order to define a UDF it would not be properly integrated
unless you handle the following:
1. Registering the op with the ImportClassMappings op registry
2. Special code paths in the op executioners that support calling user defined code
3. Special code paths for serialization to handle properly loading a samediff graph with
the correct op
4. A direct function call in samediff itself tha that handles properly registering the op as part of the graph


## Proposal


Support custom UDFS

1. An op type so the FlatBuffersMapper (used for saving graphs) knows how to save/load UDFs
2. A base class extending DynamicCustom for having clear method/constructor overrides for defining a custom op
3. An exec method where the user passes in relevant inputs and will be what gets used by the op executioner (rather than going down to c++)
4. A hook in samediff with something like: sd.udf(..)
5. An annotation or subclass scanner like we discussed for registration in relevant areas like the the ImportClassMappings


All of these components above work together to accomplish the following:
1. Annotation scanning for discovering user defined ops and registering them with the op registry
2. Users extend our base class to create their custom UDFS
3. Samediff integrates UDFS as follows:
```java
SameDiff sd = SameDiff.create();
UserDefinedCustomOp userDefinedCustomOp = ...;
SDVariable[] opOutputs = sd.doUdf(userDefinedCustomOp);
```

The above registers the op with the above graph. When an op is registered,
it is saved/loaded with the graph like any normal op would be.

4. We use annotation scanning to dynamically create ops via reflection when a graph is loaded.


Below is an example:
```java
@UserDefinedOp //annotation for discovering custom ops to register
public class TestAddUdf extends UserDefinedCustomOp { //class to extend
    //various constructors needed to create the op
    public TestAddUdf() {
        super();
    }

    public TestAddUdf(SameDiff sameDiff, SDVariable arg) {
        super(sameDiff, arg);
    }

    public TestAddUdf(SameDiff sameDiff, SDVariable[] args) {
        super(sameDiff, args);
    }

    //used to calculate the output variables when registering an op with a graph
    @Override
    public List<DataType> calculateOutputDataTypes(List<DataType> dataTypes) {
        return Arrays.asList(dataTypes.get(0));
    }

    @Override
    public void setPropertiesForFunction(Map<String, Object> properties) {
        //used to set properties when saving/loading
    }

    @Override
    public Object getValue(Field property) {
        //used to get values via reflection
        return null;
    }

    @Override
    public void setValueFor(Field target, Object value) {
        //used to set values via reflection

    }

    @Override
    public Map<String, Object> propertiesForFunction() {
        //returns properties (fields on the java class) as a map
        return Collections.emptyMap();
    }

    @Override
    public int getNumOutputs() {
        //the number of outputs for the op
        return 1;
    }

    @Override
    public String opName() {
        //the op name
        return "test_add_udf";
    }

    @Override
    public void configureFromArguments() {
       //a hook for configuring the op after it's created
    }

    @Override
    public void configureWithSameDiff(SameDiff sameDiff) {
        this.sameDiff = sameDiff;
        //a hook for configuring the op after it's instantiated
        //but needs to pull information from the samediff graph
    }

    @Override
    public boolean isInplaceCall() {
        return false;
    }

    @Override
    public List<LongShapeDescriptor> calculateOutputShape() {
        //descirbes how to calculate an output shape based on the inputs
        return Arrays.asList(inputArguments.get(0).shapeDescriptor());
    }

    @Override
    public List<LongShapeDescriptor> calculateOutputShape(OpContext oc) {
        //descirbes how to calculate an output shape based on the inputs from the op context
        return Arrays.asList(oc.getInputArrays().get(0).shapeDescriptor());
    }

    @Override
    public List<SDVariable> doDiff(List<SDVariable> f1) {
        //a custom gradient definition
        return new AddBpOp(sameDiff, larg(), rarg(), f1.get(0)).outputs();
    }

    @Override
    public void exec() {
        //the exec method for op itself, comprised of op execution and setting outputs
        //for the op
        AddOp addOp = new AddOp();
        addOp.addInputArgument(inputArguments.get(0),inputArguments.get(1));
        Nd4j.getExecutioner().exec(addOp);
        this.outputArguments.addAll(addOp.outputArguments);
    }

    @Override
    public void exec(OpContext opContext) {
        //the exec method for op itself, comprised of op execution and setting outputs
        //for the op context
        Nd4j.getExecutioner().exec(new AddOp(),opContext);
    }
}


```

With the above definition, a user just has to pass in a created op as an instantiated object.
As long as an op is annotated it is properly integrated with the samediff graph.

When executing, the special code paths in the op executioners will call exec() or exec(opContext)



## Consequences

### Advantages

* Allows users to define their own ops to make optimizations or to introduce custom ops
for use within samediff
* Augments model import by combining annotation scanning from model import with 
annotation registration of udfs with similar annotations

### Disadvantages
* A bit lower level which means users can misuse the api or encounter bugs they might not 
otherwise with ops maintained in the core framework